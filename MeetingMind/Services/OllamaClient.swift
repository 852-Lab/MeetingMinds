import Foundation

class OllamaClient {
    private let baseURL = "http://localhost:11434/api"
    private let session: URLSession
    
    init() {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 300 // 5 minutes for large models
        session = URLSession(configuration: config)
    }
    
    // MARK: - Server Status
    
    func isOllamaRunning() async -> Bool {
        guard let url = URL(string: "\(baseURL)/tags") else { return false }
        
        do {
            let (_, response) = try await session.data(from: url)
            return (response as? HTTPURLResponse)?.statusCode == 200
        } catch {
            return false
        }
    }
    
    func getAvailableModels() async throws -> [OllamaModel] {
        guard let url = URL(string: "\(baseURL)/tags") else {
            throw OllamaError.invalidURL
        }
        
        let (data, _) = try await session.data(from: url)
        let response = try JSONDecoder().decode(ModelsResponse.self, from: data)
        return response.models
    }
    
    // MARK: - Transcription
    
    func transcribe(audioURL: URL, language: String? = nil, model: String = "whisper:base") async throws -> TranscriptionResult {
        // For POC: Simplified transcription
        // In production, this would send audio to Ollama's Whisper endpoint
        
        // Read audio file
        let audioData = try Data(contentsOf: audioURL)
        
        // Create a simple prompt for transcription
        let prompt = """
        Transcribe the following audio accurately with timestamps.
        Language: \(language ?? "auto-detect")
        Provide output in JSON format with segments containing timestamp and text.
        """
        
        // For POC, we'll use a mock transcription
        // In production, implement actual Ollama Whisper API call
        
        return TranscriptionResult(
            text: "This is a sample transcription. In production, this would be generated by Whisper.",
            segments: [
                TranscriptSegment(timestamp: 0, text: "Welcome to the meeting.", confidence: 0.95),
                TranscriptSegment(timestamp: 5, text: "Let's discuss the project updates.", confidence: 0.92),
                TranscriptSegment(timestamp: 12, text: "We have three main topics to cover.", confidence: 0.94)
            ],
            language: language ?? "en"
        )
    }
    
    // MARK: - Summarization
    
    func generateSummary(transcript: String, model: String = "llama3.2") async throws -> MeetingSummary {
        guard let url = URL(string: "\(baseURL)/generate") else {
            throw OllamaError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let prompt = """
        Analyze the following meeting transcript and generate a structured summary.
        
        Format your response as JSON with this exact structure:
        {
          "title": "Meeting title or topic",
          "keyPoints": ["point 1", "point 2", "point 3"],
          "decisions": [{"text": "decision", "timestamp": "HH:MM:SS"}],
          "actionItems": [{"task": "description", "assignee": "name or null", "dueDate": "date or null"}],
          "nextSteps": ["step 1", "step 2"]
        }
        
        Transcript:
        \(transcript)
        """
        
        let body: [String: Any] = [
            "model": model,
            "prompt": prompt,
            "stream": false,
            "format": "json",
            "options": [
                "temperature": 0.3,
                "top_p": 0.9
            ]
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: body)
        
        do {
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw OllamaError.requestFailed
            }
            
            let result = try JSONDecoder().decode(GenerateResponse.self, from: data)
            
            // Parse JSON response
            guard let summaryData = result.response.data(using: .utf8) else {
                throw OllamaError.invalidResponse
            }
            
            return try JSONDecoder().decode(MeetingSummary.self, from: summaryData)
            
        } catch {
            // Fallback: return mock summary for POC
            return MeetingSummary(
                title: "Meeting Summary",
                keyPoints: [
                    "Discussed project timeline and milestones",
                    "Reviewed budget allocation",
                    "Identified key stakeholders"
                ],
                decisions: [
                    MeetingSummary.Decision(text: "Approved Q1 budget", timestamp: "00:05:30"),
                    MeetingSummary.Decision(text: "Set next meeting for next week", timestamp: "00:15:20")
                ],
                actionItems: [
                    MeetingSummary.ActionItem(task: "Prepare project proposal", assignee: "John", dueDate: "2025-11-25"),
                    MeetingSummary.ActionItem(task: "Schedule stakeholder meeting", assignee: "Sarah", dueDate: "2025-11-22")
                ],
                nextSteps: [
                    "Finalize project scope document",
                    "Begin resource allocation planning"
                ]
            )
        }
    }
}

// MARK: - Data Models

struct OllamaModel: Codable {
    let name: String
    let size: Int64
    let modified: String
}

struct ModelsResponse: Codable {
    let models: [OllamaModel]
}

struct GenerateResponse: Codable {
    let response: String
    let model: String
    let done: Bool
}

struct TranscriptionResult {
    let text: String
    let segments: [TranscriptSegment]
    let language: String
}

enum OllamaError: Error, LocalizedError {
    case notRunning
    case requestFailed
    case invalidResponse
    case modelNotFound
    case invalidURL
    
    var errorDescription: String? {
        switch self {
        case .notRunning:
            return "Ollama server is not running"
        case .requestFailed:
            return "Request to Ollama failed"
        case .invalidResponse:
            return "Invalid response from Ollama"
        case .modelNotFound:
            return "Required model not found"
        case .invalidURL:
            return "Invalid Ollama API URL"
        }
    }
}
